<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DEV CONFERENCE QUIZZ 2025</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=New+Amsterdam&family=Victor+Mono:ital,wght@0,100..700;1,100..700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* Page reset */
      html,
      body {
        height: 100%;
        margin: 0;
        background: linear-gradient(
          180deg,
          #ffecd2 0%,
          #fcb69f 50%,
          #ff7eb3 100%
        );
        color: #111;
        font-family: "Victor Mono", monospace;
        font-optical-sizing: auto;
      }

      /* Festlig bakgrund effekt */
      .confetti {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background-image: radial-gradient(
            circle at 10% 20%,
            rgba(255, 255, 255, 0.12) 0 2px,
            transparent 2px
          ),
          radial-gradient(
            circle at 80% 40%,
            rgba(255, 255, 255, 0.08) 0 2px,
            transparent 2px
          );
        mix-blend-mode: overlay;
        opacity: 0.9;
      }

      .finisher-header {
        height: 100vh;
        width: 100vw;
        position: fixed;
      }

      .app {
        min-height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        padding: 20px;
        box-sizing: border-box;
      }

      main {
        /* main area should expand to fill available space */
        flex: 1 1 0;
        display: flex;
        width: 100%;
        box-sizing: border-box;
        max-width: 80vw;
        margin: 0 auto;
        position: relative;
        min-height: 0;
      }

      /* Header */
      header.title {
        flex: 0 0 auto;
        max-width: 80vw;
        margin: 0 auto;
        text-align: center;
        padding: 20px 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .title h1 {
        margin: 0;
        font-weight: 800;
        letter-spacing: 2px;
        font-size: 48px;
        font-family: "New Amsterdam", sans-serif;
        background: linear-gradient(180deg, #fff 0%, #ffec6a 30%, #ff6b6b 70%);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        text-transform: uppercase;
      }

      .title p {
        margin: 6px 0 0 0;
        color: rgba(0, 0, 0, 0.6);
        font-size: 14px;
      }

      /* Row of boxes that share available space */
      .boxes {
        display: flex;
        gap: 14px;
        align-items: stretch;
        align-content: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        flex-wrap: wrap;
        flex: 1 1 0;
        min-height: 0;
      }

      .box {
        /* let boxes grow and wrap; choose a comfortable base width */
        flex: 1 1 22%;
        min-width: 220px;
        min-height: 160px;
        background: linear-gradient(180deg, #ffffffcc, #ffffff88);
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
        transition: background 200ms ease, transform 200ms ease,
          box-shadow 200ms ease, filter 200ms ease;
        padding: 12px;
        box-sizing: border-box;
        cursor: pointer;
        overflow: hidden;
      }

      /* Pattern (big Xs or answer) */
      .pattern {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono",
          "Segoe UI Mono", monospace;
        line-height: 1;
        text-align: center;
        font-weight: 700;
        color: rgba(0, 0, 0, 0.9);
        font-size: var(--pattern-size, 56px);
        white-space: pre-wrap;
        word-break: break-word;
      }

      /* Small always-visible hint inside each box */
      .box-hint {
        margin-top: 8px;
        font-size: var(--hint-size, 28px);
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
        max-width: 100%;
      }

      /* States */
      .box.past {
        background: linear-gradient(180deg, #222, #111);
      }
      .box.past .pattern,
      .box.past .box-hint {
        color: #fff;
      }

      .box.future {
        background: linear-gradient(180deg, #f0f0f0, #e6e6e6);
      }
      .box.future .pattern {
        color: rgba(0, 0, 0, 0.5);
      }

      .box.current {
        background: linear-gradient(180deg, #ffd24d, #ff6b6b);
        transform: translateY(-8px);
        box-shadow: 0 14px 36px rgba(255, 107, 107, 0.28);
      }
      .box.current .pattern,
      .box.current .box-hint {
        color: #111;
        font-weight: 800;
      }

      /* Blur boxes that are not active/current */
      .box:not(.current) {
        filter: blur(10px);
        opacity: 0.2;
      }
      .box.current {
        filter: none;
      }

      @keyframes pulse {
        0% {
          transform: translateY(-6px) scale(1);
        }
        50% {
          transform: translateY(-8px) scale(1.02);
        }
        100% {
          transform: translateY(-6px) scale(1);
        }
      }
      .box.current {
        animation: pulse 1.2s infinite ease-in-out;
      }

      /* Blur only the future (greyed) boxes; past/current remain sharp */
      .box.future {
        filter: blur(10px);
      }
      .box.past,
      .box.current {
        filter: none;
        opacity: 0.9 !important;
      }
      /* When reveal mode is active, remove blur for all boxes */
      body.reveal-active .box {
        filter: none !important;
      }

      /* Reveal button (shown when on last step or when reveal mode active) */
      .controls {
        flex: 0 0 auto;
        padding: 20px 0;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        min-height: 100px;
      }

      .reveal-btn {
        display: inline-block;
        padding: 14px 28px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        font-size: 18px;
        color: white;
        background: linear-gradient(90deg, #ff6b6b, #ffb86b);
        box-shadow: 0 8px 30px rgba(255, 107, 107, 0.28),
          0 2px 6px rgba(0, 0, 0, 0.12);
        cursor: pointer;
        transition: transform 160ms ease, box-shadow 160ms ease,
          opacity 160ms ease;
      }

      .reveal-btn[aria-pressed="true"] {
        background: linear-gradient(90deg, #6bffb8, #6bd1ff);
        box-shadow: 0 12px 44px rgba(107, 209, 255, 0.28),
          0 3px 8px rgba(0, 0, 0, 0.14);
      }

      .reveal-btn:active {
        transform: translateY(2px) scale(0.995);
      }

      .start-btn {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 24px 48px;
        border-radius: 999px;
        border: none;
        font-weight: 800;
        font-size: 32px;
        color: white;
        background: linear-gradient(90deg, #4caf50, #45a049);
        box-shadow: 0 12px 40px rgba(76, 175, 80, 0.4);
        cursor: pointer;
        transition: transform 160ms ease, box-shadow 160ms ease;
        z-index: 10;
      }

      .start-btn:hover {
        transform: translate(-50%, -50%) translateY(-4px);
        box-shadow: 0 16px 50px rgba(76, 175, 80, 0.5);
      }

      .start-btn:active {
        transform: translate(-50%, -50%) translateY(2px) scale(0.98);
      }

      /* Timer */
      .timer {
        font-size: 72px;
        font-weight: 800;
        color: #fff;
        text-align: center;
        margin: 20px 0;
        font-family: "Arial Black", monospace;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        transition: color 0.3s ease;
      }

      .timer.warning {
        color: #ff4444;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* Warning overlay */
      .warning-overlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 15rem;
        font-weight: 800;
        font-family: "New Amsterdam", sans-serif;
        color: #ff0000;
        text-align: center;
        z-index: 100;
        pointer-events: none;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        animation: shake 0.2s infinite;
        display: none;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        25% {
          transform: translate(-50%, -50%) rotate(-2deg);
          color:orange
        }
        75% {
          transform: translate(-50%, -50%) rotate(2deg);
        }
      }

      /* Small helper text */
      .helper {
        font-size: 13px;
        color: rgba(0, 0, 0, 0.6);
      }

      @media (max-width: 1200px) {
        .box {
          flex: 1 1 32%;
          min-width: 200px;
        }
      }

      @media (max-width: 740px) {
        .app {
          padding: 15px;
        }

        .title h1 {
          font-size: 28px;
        }

        header.title {
          padding: 15px 0;
        }

        .box {
          min-height: 110px;
          flex: 1 1 48%;
          min-width: 160px;
        }

        .controls {
          padding: 15px 0;
          min-height: 80px;
        }

        .start-btn {
          font-size: 28px;
          padding: 20px 40px;
        }
      }

      .logo {
        max-width: 3rem;
        height: auto;
        z-index: 10;
        position: absolute;
        right: 1rem;
        bottom: 1rem;
        opacity: 0.8;
        animation: flipLogo 5s infinite;
        transition: transform 2s ease-in-out;
      }

      @keyframes flipLogo {
        0% {
          transform: scaleX(1);
        }
        50% {
          transform: scaleX(1.2);
        }
        99.9% {
          transform: scaleX(1.01);
        }
      }
    </style>
  </head>

  <body>
    <div class="confetti" aria-hidden="true"></div>
    <div id="warningOverlay" class="warning-overlay">Hurry up!</div>
    <div class="finisher-header">
      <img src="grouplogo.svg" alt="Bjorn Lunden" class="logo" />
      <div class="app">
        <header class="title">
          <h1>DEV CONFERENCE QUIZZ 2025</h1>
        </header>

        <main>
          <button id="startBtn" class="start-btn" style="display: none">
            STARTA QUIZ
          </button>
          <div class="boxes" id="boxes" role="list"></div>
        </main>

        <div class="controls">
          <div id="timer" class="timer" style="display: none">- : -</div>
          <button
            id="revealBtn"
            class="reveal-btn"
            aria-pressed="false"
            style="display: none"
          >
            VISA SVAR
          </button>
        </div>
      </div>
    </div>
    <script src="finisher-header.es5.min.js" type="text/javascript"></script>
    <script>
      /* Data: pattern, hint, answer, songTitle, artist */
      const items = [
        {
          pattern: "XX",
          hint: "Ett ord från titeln (2)",
          answer: "En",
          songTitle: "En vacker död stad",
          artist: "Thåström",
        },
        {
          pattern: "XXX",
          hint: "En färg (3)",
          answer: "Gul",
          songTitle: "Banankontakt",
          artist: "Electric Banana Band",
        },
        {
          pattern: "XXXXX",
          hint: "Ett djur (5)",
          answer: "Björn",
          songTitle: "Vart jag mig i världen vänder",
          artist: "Den Svenska Björnstammen",
        },
        {
          pattern: "XXXX",
          hint: "Ett ord från titeln (4)",
          answer: "Från",
          songTitle: "Från balkongen",
          artist: "Oskar Linnros",
        },
        {
          pattern: "XXXXXXXXXXX",
          hint: "Ett landskap (11)",
          answer: "Hälsingland",
          songTitle: "Hälsingland",
          artist: "Tomas Andersson Wij",
        },
        {
          pattern: "XXXXXX",
          hint: "Ett ord från titeln (6)",
          answer: "Kommer",
          songTitle: "Kommer du ihåg?",
          artist: "Hooja",
        },
        {
          pattern: "XXX",
          hint: "Ett ord från titeln (3)",
          answer: "Slå",
          songTitle: "Slå mig hårt i ansiktet",
          artist: "Thomas Stenström",
        },
        {
          pattern: "XXXX",
          hint: "Ett ord från titeln på Svenska, skrivet i adjektivets neutrumform (5)",
          answer: "Stort",
          songTitle: "Big In Japan",
          artist: "Alphaville",
        },
        {
          pattern: "XX",
          hint: "Ett ord från titeln (2)",
          answer: "På",
          songTitle: "Lys på mig",
          artist: "Viktor Leksell",
        },
        {
          pattern: "XXXXXXXX",
          hint: "Ett annat ord för titeln (8)",
          answer: "Internet",
          songTitle: "World Wide Web",
          artist: "Nick Borgen",
        },
        {
          pattern: "XXXX XXX XX",
          hint: "Tre ord från titeln (9)",
          answer: "Häng med på",
          songTitle: "Häng med på party",
          artist: "Magnus Uggla",
        },
        {
          pattern: "XXXXXXXXXX",
          hint: "Låtens titel (10)",
          answer: "Segertåget",
          songTitle: "Segertåget",
          artist: "Maskinen",
        },
      ];

      const boxesEl = document.getElementById("boxes");
      const revealBtn = document.getElementById("revealBtn");
      const startBtn = document.getElementById("startBtn");
      const timerEl = document.getElementById("timer");
      const warningEl = document.getElementById("warningOverlay");
      let current = 0;
      let revealActive = false;
      let quizStarted = false;

      // Timer variables
      const TIMER_DURATION = 20; // 2 minutes in seconds
      const WARNING_DURATION = 10; // Show warning during last 20 seconds
      let timeRemaining = TIMER_DURATION;
      let timerInterval = null;
      let timerActive = false;

      function renderBoxes() {
        boxesEl.innerHTML = "";
        items.forEach((it, idx) => {
          const div = document.createElement("div");
          div.className = "box";
          div.setAttribute("role", "listitem");
          div.dataset.index = idx;

          const pattern = document.createElement("div");
          pattern.className = "pattern";
          pattern.textContent = renderPatternText(it, idx);

          const boxHint = document.createElement("div");
          boxHint.className = "box-hint";
          boxHint.textContent = renderHintText(it, idx);

          div.appendChild(pattern);
          div.appendChild(boxHint);

          div.addEventListener("click", () => {
            setCurrent(idx);
          });
          boxesEl.appendChild(div);
        });
        updateState();
        normalizeFontSize();
      }

      function renderPatternText(item, idx) {
        // Default: show pattern
        if (!revealActive) return item.pattern;
        // In reveal mode: only show answer for boxes we've stepped past (idx < current)
        if (revealActive && idx < current) return item.answer || item.pattern;
        return item.pattern;
      }

      function renderHintText(item, idx) {
        // Default: show hint
        if (!revealActive) return item.hint || "";
        // In reveal mode: only show songTitle — artist for boxes we've stepped past
        if (revealActive && idx < current) {
          const title = item.songTitle ? item.songTitle : "";
          const artist = item.artist ? item.artist : "";
          const joined = [title, artist].filter(Boolean).join(" — ");
          return joined || item.hint || "";
        }
        return item.hint || "";
      }

      function updateState() {
        const nodes = boxesEl.querySelectorAll(".box");
        nodes.forEach((node, idx) => {
          node.classList.remove("past", "current", "future");

          // If quiz hasn't started, all boxes should be "future" (grayed out)
          if (!quizStarted) {
            node.classList.add("future");
          } else {
            // Normal quiz logic
            if (idx < current) node.classList.add("past");
            else if (idx === current) node.classList.add("current");
            else node.classList.add("future");
          }

          // update contents (pattern & hint) depending on revealActive
          const it = items[idx];
          const patternEl = node.querySelector(".pattern");
          const hintEl = node.querySelector(".box-hint");
          if (patternEl) patternEl.textContent = renderPatternText(it, idx);
          if (hintEl) hintEl.textContent = renderHintText(it, idx);
        });

        // Show reveal button when on last step or while reveal mode active
        // Show start button only on first step and quiz not started
        if (current === 0 && !quizStarted && !revealActive) {
          startBtn.style.display = "inline-block";
          revealBtn.style.display = "none";
          timerEl.style.display = "none";
        } else {
          startBtn.style.display = "none";

          // Show reveal button on last step or in reveal mode
          const lastIndex = items.length - 1;
          if (current === lastIndex || revealActive) {
            revealBtn.style.display = "inline-block";
          } else {
            revealBtn.style.display = "none";
          }
        }

        // update button label and aria
        revealBtn.textContent = revealActive ? "DÖLJ SVAR" : "VISA SVAR";
        revealBtn.setAttribute("aria-pressed", String(revealActive));
      }

      function setCurrent(i) {
        if (i < 0) i = 0;
        // When in reveal mode we allow stepping one past the last item so its answer is revealed
        const maxIndex = revealActive ? items.length : items.length - 1;
        if (i > maxIndex) i = maxIndex;

        // Restart timer on any navigation if quiz has started and not in reveal mode
        if (quizStarted && !revealActive && i !== current) {
          resetTimer();
          if (i > 0) {
            startTimer();
          }
        }

        current = i;
        updateState();
      }

      function next() {
        if (revealActive) {
          // allow advancing up to items.length (one past last) to reveal the final answer
          if (current < items.length) setCurrent(current + 1);
        } else {
          if (current < items.length - 1) setCurrent(current + 1);
        }
      }

      function prev() {
        if (current > 0) setCurrent(current - 1);
      }

      // Timer functions
      function startTimer() {
        if (timerActive) return;

        timerActive = true;
        timerEl.style.display = "block";

        timerInterval = setInterval(() => {
          timeRemaining--;
          updateTimerDisplay();

          if (timeRemaining <= 0) {
            stopTimer();
          }
        }, 1000);
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        timerActive = false;
        timerEl.style.display = "none";
        warningEl.style.display = "none";
      }

      function resetTimer() {
        stopTimer();
        timeRemaining = TIMER_DURATION;
        updateTimerDisplay();
      }

      function updateTimerDisplay() {
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;
        const display =
          minutes > 0 ? `${minutes} min ${seconds} sek` : `${seconds} sek`;

        timerEl.textContent = display;

        // Turn red when WARNING_DURATION seconds or less remain
        if (timeRemaining <= WARNING_DURATION) {
          timerEl.classList.add("warning");
        } else {
          timerEl.classList.remove("warning");
        }

        // Show warning message when half of warning time is left
        if (timeRemaining <= WARNING_DURATION / 2) {
          warningEl.style.display = "block";
        } else {
          warningEl.style.display = "none";
        }
      }

      // Keyboard navigation
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowRight") {
          next();
          e.preventDefault();
        } else if (e.key === "ArrowLeft") {
          prev();
          e.preventDefault();
        } else if (e.key === " " || e.key === "Enter") {
          next();
          e.preventDefault();
        }
      });

      // Start button behavior: start the quiz and timer
      startBtn.addEventListener("click", () => {
        quizStarted = true;
        setCurrent(0); // Move to first question (index 0)
        startTimer(); // Start the timer
      });

      // Reveal button behavior: toggle reveal mode, jump to first, and toggle body class
      revealBtn.addEventListener("click", () => {
        if (!revealActive) {
          // Activate reveal mode: jump to first box and show answers only for passed boxes
          revealActive = true;
          current = 0;
          document.body.classList.add("reveal-active");
          stopTimer(); // Stop timer when entering reveal mode
        } else {
          // Deactivate and reset to first step
          revealActive = false;
          current = 0;
          quizStarted = false; // Reset quiz status
          document.body.classList.remove("reveal-active");
          resetTimer(); // Reset timer when leaving reveal mode
        }
        updateState();
        normalizeFontSize();
      });

      // Compute a uniform font-size so pattern text has the same scale across boxes regardless of wrapping.
      function normalizeFontSize() {
        const boxEls = Array.from(boxesEl.children);
        if (!boxEls.length) return;

        const sizes = boxEls.map((el) => {
          const rect = el.getBoundingClientRect();
          const innerW = rect.width - 24; // padding
          const innerH = rect.height - 48; // leave space for hint
          const pattern = items[parseInt(el.dataset.index, 10)].pattern;
          // longest contiguous group (word) length
          const longestWord =
            pattern.split(" ").reduce((m, w) => Math.max(m, w.length), 0) || 1;
          return { innerW, innerH, longestWord };
        });

        const candidates = sizes.map((s) => {
          const pxPerChar = s.innerW / Math.max(1, s.longestWord);
          const byWidth = pxPerChar * 1.05; // bias larger
          const byHeight = s.innerH * 0.98; // use more vertical space
          return Math.min(byWidth, byHeight);
        });

        const finalPx = Math.max(
          28,
          Math.floor(Math.min(...candidates) * 1.35)
        );
        // pattern large, hint larger
        boxesEl.style.setProperty("--pattern-size", finalPx + "px");
        boxesEl.style.setProperty(
          "--hint-size",
          Math.max(18, Math.floor(finalPx * 0.6)) + "px"
        );
      }

      // Recompute on resize
      let resizeTimeout = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(normalizeFontSize, 120);
      });

      // initial render
      renderBoxes();

      // Expose for debugging
      window.__quiz = { items, setCurrent, next, prev };

      new FinisherHeader({
        count: 10,
        size: {
          min: 1300,
          max: 1500,
          pulse: 0,
        },
        speed: {
          x: {
            min: 0.1,
            max: 0.6,
          },
          y: {
            min: 0.1,
            max: 0.6,
          },
        },
        colors: {
          background: "#9138e5",
          particles: ["#ff4848", "#000000", "#2235e5", "#000000", "#ff0000"],
        },
        blending: "overlay",
        opacity: {
          center: 0.5,
          edge: 0.05,
        },
        skew: 0,
        shapes: ["c"],
      });
    </script>
  </body>
</html>
